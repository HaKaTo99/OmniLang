module Arena3D {
    struct Vec3 {
        x: f64, y: f64, z: f64
    }

    struct Transform {
        position: Vec3,
        rotation: Vec3
    }

    struct Stats {
        hp: i32,
        armor: i32
    }

    struct Entity {
        id: i32,
        transform: Transform,
        stats: Stats,
        active: bool
    }

    fn vec3_add(a: Vec3, b: Vec3) -> Vec3 {
        return Vec3 { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };
    }

    fn calculate_distance(p1: Vec3, p2: Vec3) -> f64 {
        // Simple distance squared (simplified for engine v1.2.2)
        let dx = p1.x - p2.x;
        let dy = p1.y - p2.y;
        let dz = p1.z - p2.z;
        return (dx * dx) + (dy * dy) + (dz * dz);
    }

    fn apply_damage(entity: Entity, damage: i32) -> Entity {
        let mut e = entity;
        let actual_damage = damage - (e.stats.armor / 2);
        if (actual_damage > 0) {
            e.stats.hp = e.stats.hp - actual_damage;
        }
        if (e.stats.hp <= 0) {
            e.stats.hp = 0;
            e.active = false;
        }
        return e;
    }

    const main: i32 = {
        print("--- OmniLang 3D Arena (ECS Style) ---");
        
        let player_transform = Transform { 
            position: Vec3 { x: 10.0, y: 0.0, z: 10.0 }, 
            rotation: Vec3 { x: 0.0, y: 90.0, z: 0.0 } 
        };
        
        let mut player = Entity {
            id: 1,
            transform: player_transform,
            stats: Stats { hp: 100, armor: 20 },
            active: true
        };

        print("Player HP before damage:");
        print(player.stats.hp);

        // Combat Scenario
        player = apply_damage(player, 30);
        print("Player HP after 30 damage (with 20 armor):");
        print(player.stats.hp);

        // Move Player
        let velocity = Vec3 { x: 1.0, y: 0.0, z: 0.0 };
        player.transform.position = vec3_add(player.transform.position, velocity);
        print("New Player Position X:");
        print(player.transform.position.x);

        0
    };
}
