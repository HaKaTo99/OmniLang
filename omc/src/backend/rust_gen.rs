use crate::ir::{Instruction, Value, IrOp};

pub struct RustGenerator {
    output: String,
    indent: usize,
}

impl RustGenerator {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            indent: 0,
        }
    }

    pub fn generate(&mut self, instructions: &[Instruction]) -> String {
        self.output.clear();
        self.emit_line("// Autogenerated by OmniLang Compiler (omc) v0.5.0");
        self.emit_line("// Military Grade - High Stability Backend");
        self.emit_line("#![allow(unused_assignments, unused_variables)]");
        self.emit_line("");
        
        // Phase 7: Standard Library Functions (Runtime)
        self.emit_line("fn print(val: i64) -> i64 {");
        self.emit_line("  println!(\"{}\", val);");
        self.emit_line("  val");
        self.emit_line("}");
        self.emit_line("");

        let mut i = 0;
        while i < instructions.len() {
            let instr = &instructions[i];
            match instr {
                Instruction::FunctionStart(name, params) => {
                    let mut fn_decl = format!("fn {}(", name);
                    for (idx, param) in params.iter().enumerate() {
                        fn_decl.push_str(&format!("{}: i64", param));
                        if idx < params.len() - 1 {
                            fn_decl.push_str(", ");
                        }
                    }
                    fn_decl.push_str(") -> i64 {");
                    self.emit_line(&fn_decl);
                    self.indent += 1;
                    
                    let mut fn_instrs = vec![];
                    i += 1;
                    while i < instructions.len() {
                        if let Instruction::FunctionEnd = instructions[i] {
                            break;
                        }
                        fn_instrs.push(instructions[i].clone());
                        i += 1;
                    }
                    self.gen_function_body(&fn_instrs, params, false);
                    
                    self.indent -= 1;
                    self.emit_line("}");
                    self.emit_line("");
                }
                _ => {
                    self.emit_line("fn main() {");
                    self.indent += 1;
                    let mut global_instrs = vec![];
                    while i < instructions.len() {
                        if let Instruction::FunctionStart(..) = instructions[i] {
                            break;
                        }
                        global_instrs.push(instructions[i].clone());
                        i += 1;
                    }
                    self.gen_function_body(&global_instrs, &[], true);
                    self.indent -= 1;
                    self.emit_line("}");
                    continue; 
                }
            }
            i += 1;
        }
        self.output.clone()
    }

    fn gen_function_body(&mut self, instrs: &[Instruction], params: &[String], is_main: bool) {
        let mut vars = std::collections::HashSet::new();
        for instr in instrs {
            match instr {
                Instruction::Store(var, _) => { if !params.contains(var) { vars.insert(var.clone()); } }
                Instruction::Call(_, _, args) => {
                    for arg in args { if let Value::Variable(v) = arg { if !params.contains(v) { vars.insert(v.clone()); } } }
                }
                Instruction::Load(_, Value::Variable(v)) => { if !params.contains(v) { vars.insert(v.clone()); } }
                Instruction::Binary(_, _, v1, v2) => {
                    if let Value::Variable(v) = v1 { if !params.contains(v) { vars.insert(v.clone()); } }
                    if let Value::Variable(v) = v2 { if !params.contains(v) { vars.insert(v.clone()); } }
                }
                _ => {}
            }
        }

        for var in vars {
            self.emit_line(&format!("let mut {} = 0; // hoisted", var));
        }

        self.emit_line("let mut _stage = 0;");
        self.emit_line("loop {");
        self.indent += 1;
        self.emit_line("match _stage {");
        self.indent += 1;

        let mut stages = vec![];
        let mut current_stage = vec![];
        let mut current_label = "start".to_string();
        for instr in instrs {
            if let Instruction::Label(name) = instr {
                stages.push((current_label.clone(), current_stage.clone()));
                current_stage.clear();
                current_label = name.clone();
            } else {
                current_stage.push(instr.clone());
            }
        }
        stages.push((current_label, current_stage));

        for (idx, (label, body)) in stages.iter().enumerate() {
            self.emit_line(&format!("{} => {{ // Label: {}", idx, label));
            self.indent += 1;
            let mut terminated = false;
            for instr in body {
                if terminated { break; }
                match instr {
                    Instruction::Load(dest, val) => {
                        let val_str = self.val_to_rust(val);
                        self.emit_line(&format!("let _r{} = {};", dest, val_str));
                    }
                    Instruction::Binary(dest, op, v1, v2) => {
                        let v1_str = self.val_to_rust(v1);
                        let v2_str = self.val_to_rust(v2);
                        let (op_str, is_bool) = match op {
                            IrOp::Add => ("+", false), IrOp::Sub => ("-", false),
                            IrOp::Mul => ("*", false), IrOp::Div => ("/", false),
                            IrOp::Eq => ("==", true), IrOp::Ne => ("!=", true),
                            IrOp::Lt => ("<", true), IrOp::Gt => (">", true),
                            IrOp::Le => ("<=", true), IrOp::Ge => (">=", true),
                        };
                        if is_bool {
                            self.emit_line(&format!("let _r{} = if ({} as i64) {} ({} as i64) {{ 1 }} else {{ 0 }};", dest, v1_str, op_str, v2_str));
                        } else {
                            self.emit_line(&format!("let _r{} = ({} as i64) {} ({} as i64);", dest, v1_str, op_str, v2_str));
                        }
                    }
                    Instruction::Store(var, val) => {
                        let val_str = self.val_to_rust(val);
                        self.emit_line(&format!("{} = {};", var, val_str));
                    }
                    Instruction::Jump(target) => {
                        let target_idx = stages.iter().position(|(l, _)| l == target).unwrap_or(0);
                        self.emit_line(&format!("_stage = {}; continue;", target_idx));
                        terminated = true;
                    }
                    Instruction::CondJump(val, t, f) => {
                        let val_str = self.val_to_rust(val);
                        let t_idx = stages.iter().position(|(l, _)| l == t).unwrap_or(0);
                        let f_idx = stages.iter().position(|(l, _)| l == f).unwrap_or(0);
                        self.emit_line(&format!("if {} != 0 {{ _stage = {}; }} else {{ _stage = {}; }} continue;", val_str, t_idx, f_idx));
                        terminated = true;
                    }
                    Instruction::Call(dest, func, args) => {
                        let args_str: Vec<String> = args.iter().map(|a| self.val_to_rust(a)).collect();
                        self.emit_line(&format!("let _r{} = {}({});", dest, func, args_str.join(", ")));
                    }
                    Instruction::Return(val) => {
                        let val_str = val.as_ref().map(|v| self.val_to_rust(v)).unwrap_or("0".to_string());
                        self.emit_line(&format!("return {};", val_str));
                        terminated = true;
                    }
                    _ => {}
                }
            }
            if !terminated {
                if idx < stages.len() - 1 {
                    self.emit_line(&format!("_stage = {}; continue;", idx + 1));
                } else {
                    self.emit_line("break;");
                }
            }
            self.indent -= 1;
            self.emit_line("}");
        }
        self.emit_line("_ => break,");
        self.indent -= 1;
        self.emit_line("}");
        self.indent -= 1;
        self.emit_line("}");
        if !is_main {
            self.emit_line("0");
        }
    }

    fn val_to_rust(&self, val: &Value) -> String {
        match val {
            Value::LiteralInt(i) => i.to_string(),
            Value::LiteralString(s) => format!("\"{}\".to_string()", s),
            Value::LiteralBool(b) => if *b { "1".into() } else { "0".into() },
            Value::Register(r) => format!("_r{}", r),
            Value::Variable(v) => v.clone(),
        }
    }

    fn emit_line(&mut self, line: &str) {
        let padding = "  ".repeat(self.indent);
        self.output.push_str(&format!("{}{}\n", padding, line));
    }
}
